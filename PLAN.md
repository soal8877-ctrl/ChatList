# План реализации программы ChatList

## Этап 1: Подготовка проекта и структуры

1.1. Создать структуру проекта:
   - `main.py` - главный файл с GUI интерфейсом
   - `db.py` - модуль для работы с базой данных SQLite
   - `models.py` - модуль для работы с моделями нейросетей
   - `network.py` - модуль для отправки HTTP запросов к API
   - `.env` - файл для хранения API ключей
   - `requirements.txt` - зависимости проекта

1.2. Установить зависимости:
   - PyQt5 (GUI)
   - requests или httpx (HTTP запросы)
   - python-dotenv (работа с .env файлом)
   - sqlite3 (встроенная библиотека Python)

## Этап 2: Реализация базы данных (db.py)

2.1. Создать класс Database для работы с SQLite:
   - Метод инициализации БД (создание таблиц если их нет)
   - Методы для работы с таблицей `prompts`:
     - `add_prompt(date, prompt, tags)` - добавление промта
     - `get_prompts()` - получение всех промтов
     - `search_prompts(query)` - поиск промтов
   - Методы для работы с таблицей `models`:
     - `add_model(name, api_url, api_id, is_active)` - добавление модели
     - `get_active_models()` - получение активных моделей
     - `update_model_status(model_id, is_active)` - обновление статуса
   - Методы для работы с таблицей `results`:
     - `save_results(results_list)` - сохранение результатов
     - `get_results()` - получение сохраненных результатов
     - `search_results(query)` - поиск результатов
   - Методы для работы с таблицей `settings`:
     - `get_setting(key)` - получение настройки
     - `set_setting(key, value)` - сохранение настройки

2.2. Реализовать создание всех таблиц при первом запуске

## Этап 3: Реализация работы с моделями (models.py)

3.1. Создать класс Model для представления модели нейросети:
   - Атрибуты: id, name, api_url, api_id, is_active
   - Методы для получения данных из БД

3.2. Реализовать поддержку разных типов API:
   - OpenAI API
   - DeepSeek API
   - Groq API
   - (возможно другие в будущем)

3.3. Создать фабрику для создания правильного обработчика API в зависимости от типа модели

## Этап 4: Реализация сетевых запросов (network.py)

4.1. Создать базовый класс APIHandler:
   - Абстрактный метод `send_request(prompt, api_key)`

4.2. Реализовать конкретные обработчики для каждого типа API:
   - `OpenAIHandler` - для OpenAI API
   - `DeepSeekHandler` - для DeepSeek API
   - `GroqHandler` - для Groq API

4.3. Реализовать асинхронную отправку запросов к нескольким моделям одновременно

4.4. Добавить обработку ошибок:
   - Таймауты
   - Ошибки API
   - Сетевые ошибки

## Этап 5: Реализация GUI интерфейса (main.py)

5.1. Создать главное окно приложения (MainWindow):
   - Область ввода промта (QTextEdit)
   - Кнопка "Отправить"
   - Выпадающий список для выбора сохраненного промта
   - Таблица результатов (QTableWidget) с колонками:
     - Название модели
     - Текст ответа
     - Чекбокс "Выбрать"
   - Кнопка "Сохранить выбранные"
   - Кнопка "Новый запрос"

5.2. Реализовать временную таблицу результатов в памяти:
   - Структура данных для хранения результатов (список словарей)
   - Методы для добавления/удаления результатов

5.3. Реализовать обработчики событий:
   - Отправка промта в модели
   - Отображение результатов в таблице
   - Сохранение выбранных результатов
   - Очистка временной таблицы

5.4. Добавить меню и дополнительные окна:
   - Меню "Модели" - управление моделями
   - Меню "Промты" - просмотр сохраненных промтов
   - Меню "Результаты" - просмотр сохраненных результатов
   - Меню "Настройки" - настройки программы

## Этап 6: Интеграция компонентов

6.1. Подключить db.py к main.py
6.2. Подключить models.py к network.py
6.3. Подключить network.py к main.py
6.4. Реализовать полный цикл работы:
   - Ввод промта → Отправка → Получение ответов → Отображение → Сохранение

## Этап 7: Дополнительные функции

7.1. Реализовать поиск и сортировку во всех таблицах:
   - Поиск по тексту в таблице промтов
   - Поиск по тексту в таблице результатов
   - Сортировка по дате, названию модели и т.д.

7.2. Реализовать экспорт результатов:
   - Экспорт в Markdown
   - Экспорт в JSON

7.3. Добавить логирование запросов:
   - Логирование всех запросов к API
   - Сохранение логов в файл или БД

7.4. Улучшить UI/UX:
   - Индикатор загрузки при отправке запросов
   - Обработка ошибок с понятными сообщениями
   - Валидация ввода

7.5. Реализовать функцию "AI-ассистент для улучшения промтов":
   - Создать модуль `prompt_improver.py` для логики улучшения промтов
   - Реализовать класс `PromptImprover`:
     - Метод `improve_prompt(original_prompt, model_id)` - отправка запроса на улучшение
     - Метод `generate_variants(original_prompt, model_id)` - генерация вариантов переформулировки
     - Метод `adapt_for_model_type(prompt, model_type)` - адаптация под разные типы моделей
   - Создать промт-шаблоны для AI-ассистента:
     - Шаблон для улучшения промта (более четкий, структурированный)
     - Шаблон для генерации вариантов (2-3 альтернативные формулировки)
     - Шаблоны адаптации под типы моделей (код, анализ, креатив)
   - Реализовать диалоговое окно `PromptImprovementDialog`:
     - Отображение исходного промта
     - Отображение улучшенной версии
     - Отображение 2-3 вариантов переформулировки
     - Отображение адаптированных версий для разных типов моделей
     - Кнопки "Подставить в поле ввода" для каждого варианта
     - Кнопка "Закрыть"
   - Добавить в главное окно:
     - Кнопку "Улучшить промт" рядом с полем ввода промта
     - Обработчик нажатия кнопки, открывающий диалог улучшения
   - Интеграция с существующей системой моделей:
     - Выбор модели для улучшения (по умолчанию - первая активная модель OpenRouter)
     - Использование существующего `OpenRouterHandler` из `network.py`
     - Обработка ошибок API при улучшении промта
   - Добавить настройки:
     - Сохранение выбранной модели для улучшения промтов в таблицу `settings`
     - Возможность выбора модели для улучшения в диалоге

## Этап 8: Тестирование и оптимизация

8.1. Тестирование основных функций:
   - Работа с БД
   - Отправка запросов к API
   - Сохранение результатов
   - Поиск и сортировка

8.2. Тестирование на разных моделях и API

8.3. Оптимизация производительности:
   - Асинхронные запросы
   - Кэширование данных

8.4. Исправление найденных ошибок

## Этап 9: Создание исполняемого файла

9.1. Настроить PyInstaller для создания .exe файла
9.2. Протестировать исполняемый файл на чистой системе
9.3. Убедиться, что все зависимости включены

